from fastapi import FastAPI, HTTPException, Response, Request, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.exceptions import RequestValidationError, HTTPException
from starlette.middleware.sessions import SessionMiddleware
from starlette.requests import Request
from starlette.responses import JSONResponse
from contextlib import asynccontextmanager

import os
import logging
import asyncio
from typing import Dict, AsyncIterator, Any

from app.core.config import settings
from app.api.api_v1.api import api_router
from app.core.logging_config import setup_logging
from app.db.session import engine, Base, init_db
from app.core.cache import cache as redis_cache
from app.lifespan import lifespan as app_lifespan
from app.core.limiter import init_rate_limiter, close_rate_limiter, get_rate_limiter

# Configuration du logging
logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncIterator[None]:
    # Démarrage de l'application
    logger.info("Démarrage de l'application...")
    
    # Initialisation de la base de données
    logger.info("Initialisation de la base de données...")
    
    # Initialisation du cache Redis...
    logger.info("initialisation du cache Redis...")
    try:
        await redis_cache.init_redis()
        logger.info("Cache Redis initialisé avec succès")
    except Exception as e:
        logger.error(f"Échec de l'initialisation du cache Redis : {e}")
        if settings.ENVIRONMENT != "test":  # Ne pas échouer en environnement de test
            raise
    
    # Initialisation du rate limiter (sautée en environnement de test)
    if settings.ENVIRONMENT != "test":
        logger.info("Initialisation du rate limiter...")
        try:
            await init_rate_limiter()
            logger.info("Rate limiter initialisé avec succès")
        except Exception as e:
            logger.error(f"Échec de l'initialisation du rate limiter : {e}")
            if settings.ENVIRONMENT != "test":
                raise
    else:
        logger.info("Rate limiter désactivé pour les tests")
    logger.info("Démarrage de la surveillance de la base de données...")
    from app.core import db_monitor
    monitor_task = asyncio.create_task(db_monitor.start_monitoring(interval=300))  # Toutes les 5 minutes
    
    try:
        yield  # L'application est en cours d'exécution
    finally:
        # Arrêt de l'application
        logger.info("Arrêt de l'application...")
        
        # Arrêter la surveillance de la base de données
        if monitor_task and not monitor_task.done():
            monitor_task.cancel()
            try:
                await monitor_task
            except asyncio.CancelledError:
                pass
            logger.info("Surveillance de la base de données arrêtée")
        
        # Fermer la connexion Redis et le rate limiter
        logger.info("Fermeture des connexions...")
        try:
            await close_rate_limiter()
            logger.info("Connexion du rate limiter fermée avec succès")
        except Exception as e:
            logger.error(f"Erreur lors de la fermeture du rate limiter : {e}")
            
        try:
            await redis_cache.close()
            logger.info("Connexion Redis fermée avec succès")
        except Exception as e:
            logger.error(f"Erreur lors de la fermeture de la connexion Redis : {e}")

def create_application() -> FastAPI:
    """Crée et configure l'application FastAPI."""
    application = FastAPI(
        title=settings.PROJECT_NAME,
        description="GW2 WvW Builder API - Optimize your WvW compositions for Guild Wars 2",
        version="0.1.0",
        openapi_url=f"{settings.API_V1_STR}/openapi.json",
        docs_url="/docs",
        redoc_url="/redoc",
        lifespan=lifespan
    )

    # Set up CORS
    if settings.BACKEND_CORS_ORIGINS:
        application.add_middleware(
            CORSMiddleware,
            allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )

    # Set up GZip compression for responses
    application.add_middleware(GZipMiddleware, minimum_size=1000)

    # Set up session middleware
    application.add_middleware(
        SessionMiddleware,
        secret_key=settings.SECRET_KEY,
        session_cookie="session",
        max_age=14 * 24 * 60 * 60,  # 14 days in seconds
    )

    # Add security headers middleware
    @application.middleware("http")
    async def add_security_headers(request: Request, call_next):
        """Ajoute des en-têtes de sécurité de base aux réponses."""
        response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        # Ajout de l'en-tête X-XSS-Protection pour la compatibilité avec les anciens navigateurs
        response.headers["X-XSS-Protection"] = "1; mode=block"
        # Politique de sécurité du contenu
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self'; object-src 'none';"
        return response


    # Include API routes
    application.include_router(api_router, prefix=settings.API_V1_STR)

    # Set up static files if present (skip in test envs without static dir)
    print(f"Environment: {settings.ENVIRONMENT}")
    static_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "static"))
    
    try:
        # Always create the static directory if it doesn't exist
        os.makedirs(static_dir, exist_ok=True)
        
        # Create a .gitkeep file if the directory is empty
        if not os.listdir(static_dir):
            with open(os.path.join(static_dir, ".gitkeep"), "w") as f:
                f.write("")
        
        # Only mount static files if not in test environment
        if settings.ENVIRONMENT != "test":
            print(f"Mounting static directory at: {static_dir}")
            application.mount("/static", StaticFiles(directory=static_dir), name="static")
        else:
            print("Skipping static files mount in test environment")
            
    except Exception as e:
        print(f"Warning: Could not set up static files: {e}")
        if settings.ENVIRONMENT != "test":
            raise

    # Set up logging
    setup_logging()

    # Create database tables (in development)
    if settings.DEBUG:
        Base.metadata.create_all(bind=engine)

    # Add exception handlers
    @application.exception_handler(HTTPException)
    async def http_exception_handler(
        request: Request, exc: HTTPException
    ) -> JSONResponse:
        return JSONResponse(
            status_code=exc.status_code,
            content={"detail": exc.detail},
        )

    @application.exception_handler(RequestValidationError)
    async def validation_exception_handler(
        request: Request, exc: RequestValidationError
    ) -> JSONResponse:
        return JSONResponse(
            status_code=422,
            content={"detail": exc.errors(), "body": exc.body},
        )

    @application.exception_handler(500)
    async def internal_exception_handler(
        request: Request, exc: Exception
    ) -> JSONResponse:
        return JSONResponse(
            status_code=500,
            content={"detail": "Internal server error"},
        )

    # Add health check endpoint
    @application.get("/health")
    async def health_check() -> Dict[str, str]:
        return {
            "status": "ok",
            "database": "ok",
            "version": settings.API_VERSION
        }

    # Add root endpoint
    @application.get("/")
    async def root() -> Dict[str, str]:
        return {
            "message": f"Welcome to the {settings.PROJECT_NAME} API",
            "docs": "/docs",
        }

    return application


# Create the application only when needed
def get_application() -> FastAPI:
    """Create and configure the FastAPI application."""
    return create_application()


# For backward compatibility, create the app when imported directly
app = get_application()


# This allows the application to be run directly with: python -m app.main
if __name__ == "__main__":
    import uvicorn
